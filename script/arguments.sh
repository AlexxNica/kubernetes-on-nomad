#!/bin/bash

help_msg () {
  cat <<EOF
Alpha Commands:
  cluster apply            Installs and starts a Nomad cluster given a kon.conf

Setup Commands (high level):
  setup node               Installs and starts all software needed for running Kubernetes on node.

Consul Commands:
  consul install           Installs Consul
  consul start             Starts Consul, --bootstrap and --interface arguments are required
  consul start bootstrap   Starts a bootstrap Consul, --interface argument are required
  consul stop              Disables Consul DNS and restores the original resolve config and stopps the local Consul agent.
  consul dns enable        Enables all DNS lookups through Consul
  consul dns disable       Disables all DNS lookups through Consul and restores the original config

Nomad Commands:
  nomad env                Environment commands for connecting to nomad.
  nomad install            Installs Nomad
  nomad start              Starts Nomad
  nomad restart            Restarts Nomad
  nomad stop               Stops Nomad

Etcd Commands:
  etcd config              Configures the etcd cluster.
  etcd start               Starts the etcd cluster.
  etcd stop                Stopps the etcd cluster.
  etcd reset               Stopps etcd and deletes all configuration.

Kubernetes Commands:
  kubernetes install       Installs kubernetes components: kubelet, kubeadm and kubectl
  kubernetes config        Configures all Kubernetes components
  kubernetes start         Starts all Kubernetes components
  kubernetes stop          Stopps all kubernetes components
  kubernetes reset         Stopps all kubernetes components and deletes all configuration.

Other Commands:
  view status              Shows kon status.
  update                   Update to the latest version.

EOF
}

# Created by argbash-init v2.5.0
# ARG_OPTIONAL_SINGLE([config],[c],[Configuration file to use],[])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Run kon in debug mode (bash -x)],[off])
# ARG_OPTIONAL_BOOLEAN([quiet],[],[Quiet mode, output less],[off])
# ARG_OPTIONAL_BOOLEAN([yes],[],[Answers yes to all questions],[off])
# ARG_OPTIONAL_BOOLEAN([print],[],[A boolean option with long flag (and implicit default: off)])
# ARG_POSITIONAL_MULTI([command],[Positional arg description],[3],[""],[""])
# ARG_HELP([KON helps you setup and run Kubernetes On Nomad (KON).\n],[$(help_msg)])
# ARG_VERSION([echo $(cat $SCRIPTDIR/version)])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.5.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='chv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_command=('' "" "")
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_config=
_arg_debug=off
_arg_quiet=off
_arg_yes=off
_arg_print=off

print_help ()
{
  printf "%s\n" "KON helps you setup and run Kubernetes On Nomad (KON).
		"
  printf 'Usage: %s [-c|--config <arg>] [--(no-)debug] [--(no-)quiet] [--(no-)yes] [--(no-)print] [-h|--help] [-v|--version] <command-1> [<command-2>] [<command-3>]\n' "$0"
  printf "\t%s\n" "<command>: Positional arg description (defaults for <command-2> to <command-3> respectively: '""' and '""')"
  printf "\t%s\n" "-c,--config: Configuration file to use (no default)"
  printf "\t%s\n" "--debug,--no-debug: Run kon in debug mode (bash -x) (off by default)"
  printf "\t%s\n" "--quiet,--no-quiet: Quiet mode, output less (off by default)"
  printf "\t%s\n" "--yes,--no-yes: Answers yes to all questions (off by default)"
  printf "\t%s\n" "--print,--no-print: A boolean option with long flag (and implicit default: off) (off by default)"
  printf "\t%s\n" "-h,--help: Prints help"
  printf "\t%s\n" "-v,--version: Prints version"
  printf "\n%s\n" "$(help_msg)"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -c|--config)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_config="$2"
        shift
        ;;
      --config=*)
        _arg_config="${_key##--config=}"
        ;;
      -c*)
        _arg_config="${_key##-c}"
        ;;
      --no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      --no-quiet|--quiet)
        _arg_quiet="on"
        test "${1:0:5}" = "--no-" && _arg_quiet="off"
        ;;
      --no-yes|--yes)
        _arg_yes="on"
        test "${1:0:5}" = "--no-" && _arg_yes="off"
        ;;
      --no-print|--print)
        _arg_print="on"
        test "${1:0:5}" = "--no-" && _arg_print="off"
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        echo $(cat $SCRIPTDIR/version)
        exit 0
        ;;
      -v*)
        echo $(cat $SCRIPTDIR/version)
        exit 0
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'command'"
  test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 3 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
  test ${#_positionals[@]} -gt 3 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 3 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_command[0]' '_arg_command[1]' '_arg_command[2]' )

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}


# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


if [ "$_arg_print" = on ]
then
  echo "Command arg value: '${_arg_command[*]}'"
  echo "Optional arg '--config|-c' value: '$_arg_config'"
  echo "Optional arg '--bootstrap|-b' value: '$_arg_bootstrap'"
  echo "Optional arg '--debug' value: '$_arg_debug'"
  echo "Optional arg '--quiet' value: '$_arg_quiet'"
  echo "Optional arg '--interface|-i' value: '$_arg_interface'"
fi

# ] <-- needed because of Argbash
