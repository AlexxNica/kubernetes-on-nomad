#!/bin/bash

help_msg () {
  cat <<EOF
Setup Commands (high level):
  setup node bootstrap     Installs and starts all software needed for running Kubernetes on bootstrap node.
  setup node               Installs and starts all software needed for running Kubernetes on node.
  setup kubectl            Configures kubectl for accessing the cluster.

Generate Commands:
  generate init            Generates a sample /etc/kon.conf file
  generate all             Generates etcd configuration, certificates and kubeconfigs.
  generate etcd            Reads the etcd configuration and stores it in consul.
  generate certificates    Generates all certificates and stores them in consul. The command only generates missing certificates and is safe to be run multiple times.
  generate kubeconfigs     Generates all kubeconfig-files and stores them in consul.

Start Commands:
  start kubelet
  start kube-proxy
  start control-plane

Reset Commands:
  reset all                Stopps all running jobs and deletes all certificates and configuration.
  reset etcd               Stopps etcd and deletes all configuration.
  reset kubernetes         Stopps kubernetes control plane and deletes all certificates and configuration.

Consul Commands:
  consul install           Installs Consul
  consul start             Starts Consul, --bootstrap and --interface arguments are required
  consul start bootstrap   Starts a bootstrap Consul, --interface argument are required
  consul dns enable        Enables all DNS lookups through Consul
  consul dns disable       Disables all DNS lookups through Consul and restores the original config

Nomad Commands:
  nomad install            Installs Nomad
  nomad start              Starts Nomad
  nomad restart            Restarts Nomad
  nomad stop               Stops Nomad

Etcd Commands:
  etcd start               Starts the etcd cluster.
  etcd stop                Stopps the etcd cluster.
  etcd reset               Stopps etcd and deletes all configuration.

Kubernetes Commands:
  kubernetes start         Starts all Kubernetes components
  kubernetes install       Installs kubernetes components: kubelet, kubeadm and kubectl
  kubernetes reset         Stopps kubernetes control plane and deletes all certificates and configuration.

Other Commands:
  addon dns                Installs dns addon.
  view status              Shows kon status.

EOF
}

# Created by argbash-init v2.5.0
# ARG_OPTIONAL_SINGLE([config],[c],[Configuration file to use],[])
# ARG_OPTIONAL_SINGLE([interface],[i],[Network interface to use for Consul bind address],[])
# ARG_OPTIONAL_SINGLE([bootstrap],[b],[Bootstrap Consul Server],[])
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[Run kon quiet, default: off],[off])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Run kon in debug mode (bash -x)],[])
# ARG_OPTIONAL_BOOLEAN([print],[],[A boolean option with long flag (and implicit default: off)])
# ARG_POSITIONAL_MULTI([command],[Positional arg description],[3],[""])
# ARG_HELP([KON helps you setup and run Kubernetes On Nomad (KON).\n],[$(help_msg)])
# ARG_VERSION([echo kon v0.1-alpha])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.5.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='cibqdhv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_command=('' '' "")
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_config=
_arg_interface=
_arg_bootstrap=
_arg_quiet=off
_arg_debug=off
_arg_print=off

print_help ()
{
  printf "%s\n" "KON helps you setup and run Kubernetes On Nomad (KON).
		"
  printf 'Usage: %s [-c|--config <arg>] [-i|--interface <arg>] [-b|--bootstrap <arg>] [-q|--(no-)quiet] [-d|--(no-)debug] [--(no-)print] [-h|--help] [-v|--version] <command-1> <command-2> [<command-3>]\n' "$0"
  printf "\t%s\n" "<command>: Positional arg description (defaults for <command-3>: '""')"
  printf "\t%s\n" "-c,--config: Configuration file to use (no default)"
  printf "\t%s\n" "-i,--interface: Network interface to use for Consul bind address (no default)"
  printf "\t%s\n" "-b,--bootstrap: Bootstrap Consul Server (no default)"
  printf "\t%s\n" "-q,--quiet,--no-quiet: Run kon quiet, default: off (off by default)"
  printf "\t%s\n" "-d,--debug,--no-debug: Run kon in debug mode (bash -x) (off by default)"
  printf "\t%s\n" "--print,--no-print: A boolean option with long flag (and implicit default: off) (off by default)"
  printf "\t%s\n" "-h,--help: Prints help"
  printf "\t%s\n" "-v,--version: Prints version"
  printf "\n%s\n" "$(help_msg)"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -c|--config)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_config="$2"
        shift
        ;;
      --config=*)
        _arg_config="${_key##--config=}"
        ;;
      -c*)
        _arg_config="${_key##-c}"
        ;;
      -i|--interface)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_interface="$2"
        shift
        ;;
      --interface=*)
        _arg_interface="${_key##--interface=}"
        ;;
      -i*)
        _arg_interface="${_key##-i}"
        ;;
      -b|--bootstrap)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_bootstrap="$2"
        shift
        ;;
      --bootstrap=*)
        _arg_bootstrap="${_key##--bootstrap=}"
        ;;
      -b*)
        _arg_bootstrap="${_key##-b}"
        ;;
      -q|--no-quiet|--quiet)
        _arg_quiet="on"
        test "${1:0:5}" = "--no-" && _arg_quiet="off"
        ;;
      -q*)
        _arg_quiet="on"
        _next="${_key##-q}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-q" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -d|--no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      -d*)
        _arg_debug="on"
        _next="${_key##-d}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      --no-print|--print)
        _arg_print="on"
        test "${1:0:5}" = "--no-" && _arg_print="off"
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        echo kon v0.1-alpha
        exit 0
        ;;
      -v*)
        echo kon v0.1-alpha
        exit 0
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'command' (2 times)"
  test ${#_positionals[@]} -lt 2 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 2 and 3 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
  test ${#_positionals[@]} -gt 3 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 2 and 3 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_command[0]' '_arg_command[1]' '_arg_command[2]' )

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


if [ "$_arg_print" = on ]
then
  echo "Command arg value: '${_arg_command[*]}'"
  echo "Optional arg '--config|-c' value: '$_arg_config'"
  echo "Optional arg '--bootstrap|-b' value: '$_arg_bootstrap'"
  echo "Optional arg '--debug|-d' value: '$_arg_debug'"
  echo "Optional arg '--interface|-i' value: '$_arg_interface'"
fi

# ] <-- needed because of Argbash
